!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@jacraig/woodchuck")):"function"==typeof define&&define.amd?define(["exports","@jacraig/woodchuck"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).request={},e.woodchuck)}(this,(function(e,t){"use strict";class r{constructor(e,r,a){this.dbName=e,this.tables=r,this.version=a;const o=indexedDB.open(e,a);o.onupgradeneeded=e=>{if(this.database=e.target.result,this.database)for(const e of r)this.database.objectStoreNames.contains(e)&&this.database.deleteObjectStore(e),this.database.createObjectStore(e)},o.onsuccess=e=>{this.database=e.target.result},o.onerror=e=>{t.Logger.error("Failed to open the database:",e.target.error)}}openDatabase(){return new Promise(((e,r)=>{const a=indexedDB.open(this.dbName,this.version);a.onsuccess=t=>{this.database=t.target.result,e(this)},a.onerror=e=>{t.Logger.error("Failed to open the database:",e.target.error),r(new Error("Failed to open the database:"+e.target.error))}}))}add(e,r,a){return new Promise(((o,s)=>{if(!this.database)return t.Logger.error("Database connection is not open"),void s(new Error("Database connection is not open"));const i=this.database.transaction(e,"readwrite").objectStore(e).put(r,a);i.onsuccess=()=>{o()},i.onerror=e=>{t.Logger.error("Failed to add an object to the database: ",e.target.error),s(new Error("Failed to add an object to the database: "+e.target.error))}}))}remove(e,r){return new Promise(((a,o)=>{if(!this.database)return t.Logger.error("Database connection is not open"),void o(new Error("Database connection is not open"));const s=this.database.transaction(e,"readwrite").objectStore(e).delete(r);s.onsuccess=()=>{a()},s.onerror=e=>{t.Logger.error("Failed to remove an object from the database: ",e.target.error),o(new Error("Failed to remove an object from the database: "+e.target.error))}}))}getByKey(e,r){return new Promise(((a,o)=>{if(!this.database)return t.Logger.error("Database connection is not open"),void o(new Error("Database connection is not open"));const s=this.database.transaction(e,"readwrite").objectStore(e).get(r);s.onsuccess=e=>{a(e.target.result)},s.onerror=e=>{t.Logger.error("Failed to retrieve an object from the database: ",e.target.error),o(new Error("Failed to retrieve an object from the database: "+e.target.error))}}))}getKeys(e){return new Promise(((r,a)=>{if(!this.database)return t.Logger.error("Database connection is not open"),void a(new Error("Database connection is not open"));const o=this.database.transaction(e,"readwrite").objectStore(e).getAllKeys();o.onsuccess=e=>{r(e.target.result)},o.onerror=e=>{t.Logger.error("Failed to retrieve an object from the database: ",e.target.error),a(new Error("Failed to retrieve keys from the database: "+e.target.error))}}))}get(e,r){return new Promise(((a,o)=>{if(!this.database)return t.Logger.error("Database connection is not open"),void o(new Error("Database connection is not open"));const s=this.database.transaction(e,"readwrite").objectStore(e).get(r);s.onsuccess=e=>{a(e.target.result)},s.onerror=e=>{t.Logger.error("Failed to retrieve an object from the database: ",e.target.error),o(new Error("Failed to retrieve an object from the database: "+e.target.error))}}))}getAll(e,r){return new Promise(((a,o)=>{if(!this.database)return t.Logger.error("Database connection is not open"),void o(new Error("Database connection is not open"));const s=this.database.transaction(e,"readwrite").objectStore(e).getAll(r);s.onsuccess=e=>{a(e.target.result)},s.onerror=e=>{t.Logger.error("Failed to retrieve an object from the database: ",e.target.error),o(new Error("Failed to retrieve objects from the database: "+e.target.error))}}))}}class a{constructor(){this.database=new r("cacheStore",["cache","cacheEntryOptions"],1)}async clear(){await this.database.openDatabase();let e=await this.database.getAll("cacheEntryOptions"),t=await this.database.getAll("cache");for(let r=0;r<e.length;r++){let e=t[r];await this.remove(e.key)}return this}async getOptions(e){return await this.database.openDatabase(),this.database.getByKey("cacheEntryOptions",e)}async add(e,t,r){return await this.database.openDatabase(),await this.database.add("cache",e,t),await this.database.add("cacheEntryOptions",r,t),this}async remove(e){return await this.database.openDatabase(),await this.database.remove("cache",e),await this.database.remove("cacheEntryOptions",e),this}async get(e){return await this.database.openDatabase(),this.database.getByKey("cache",e)}async compact(){await this.database.openDatabase();let e=await this.database.getAll("cacheEntryOptions"),t=await this.database.getAll("cache"),r=(new Date).getTime();for(let a=0;a<e.length;a++){let o=e[a],s=t[a];0!=o.expirationTime&&(o.expirationTime<r&&await this.remove(s.key))}return this}}class o{constructor(){}static configure(e=new a){this.storageProvider??=globalThis.StorageProvider||e||new a,globalThis.StorageProvider=this.storageProvider}static async set(e,r,a={expirationTime:0,slidingExpirationTime:0,sliding:!1}){t.Logger.debug("Setting object in cache: ",{key:e,value:r,entryOptions:a}),this.configure(),await this.storageProvider.add(r,e,a)}static async get(e){t.Logger.debug("Getting object from cache: "+e),this.configure(),await this.storageProvider.compact();let r=await this.storageProvider.get(e);if(null==r)return r;let a=await this.storageProvider.getOptions(e);return a.sliding&&await this.set(e,r,{expirationTime:(new Date).getTime()+a.slidingExpirationTime,slidingExpirationTime:a.slidingExpirationTime,sliding:!0}),r}static async remove(e){t.Logger.debug("Removing object from cache: "+e),this.configure(),await this.storageProvider.remove(e)}static async clear(){t.Logger.debug("Clearing cache"),this.configure(),await this.storageProvider.clear()}}class s{constructor(r){this.options={method:"GET",url:"",headers:{},credentials:"same-origin",serializer:JSON.stringify,parser:e=>e.json(),success:e=>{t.Logger.debug("Request response from "+this.options.url+":",e)},error:e=>{t.Logger.error("Request error from "+this.options.url+":",e)},retry:e=>{t.Logger.debug("Request retry on "+this.options.url+":",{attempt:e})},storageMode:e.StorageMode.NetworkFirst,cacheKey:"",timeout:6e4,retryAttempts:3,retryDelay:1e3},this.abortController=null,this.options={...this.options,...r}}static get(e,t){return new s({method:"GET",url:e,data:t,cacheKey:e+JSON.stringify(t)}).withHeaders({Accept:"application/json"})}static post(t,r){return new s({method:"POST",url:t,data:r,cacheKey:t+JSON.stringify(r),storageMode:e.StorageMode.NetworkOnly}).withHeaders({"Content-Type":"application/json",Accept:"application/json"})}static put(t,r){return new s({method:"PUT",url:t,data:r,cacheKey:t+JSON.stringify(r),storageMode:e.StorageMode.NetworkOnly}).withHeaders({"Content-Type":"application/json",Accept:"application/json"})}static delete(t,r){return new s({method:"DELETE",url:t,data:r,cacheKey:t+JSON.stringify(r),storageMode:e.StorageMode.NetworkOnly}).withHeaders({Accept:"application/json"})}static ofType(e,t,r){return new s({method:e,url:t,data:r,cacheKey:t+JSON.stringify(r)}).withHeaders({Accept:"application/json"})}withAuthenticationProvider(e){return this.options.authenticationProvider=e,this}withHeaders(e){return this.options.headers={...this.options.headers,...e},this}withCancellationToken(e){return this.options.cancellationToken=e,this}withCredentials(e){return this.options.credentials=e,this}withSerializer(e){return this.options.serializer=e,this}withParser(e){return this.options.parser=e,this}onSuccess(e){return this.options.success=e??(e=>{t.Logger.debug("Request response:",e)}),this}onError(e){return this.options.error=e??(e=>{t.Logger.error("Request error:",e)}),this}onRetry(e){return this.options.retry=e??(e=>{t.Logger.debug("Request retry:",{attempt:e})}),this}withStorageMode(e){return this.options.storageMode=e,this}withCacheKey(e){return this.options.cacheKey=e,this}withTimeout(e){return this.options.timeout=e??6e4,this}withRetryAttempts(e){return this.options.retryAttempts=e,this}withRetryDelay(e){return this.options.retryDelay=e,this}abort(){return null==this.abortController||null==this.options.error||(this.abortController.abort(),this.options.error(new Error("The request was aborted."))),this}async send(){const{authenticationProvider:r,method:a,url:s,data:i,headers:n,credentials:c,serializer:d,parser:h,success:g,error:l,storageMode:u,cacheKey:b,timeout:p,retryAttempts:w,retryDelay:m,retry:y,cancellationToken:f}=this.options,v=new AbortController;this.abortController=v;let S=0,j=null,E=g||(e=>{t.Logger.debug("Request response from "+s+":",e)}),T=l||(e=>{t.Logger.error("Request error from "+s+":",e)}),P=d||JSON.stringify,D=h||(e=>e.json()),L=y||(e=>{t.Logger.debug("Request retry on "+s+":",{attempt:e})});const O=async()=>{if(u===e.StorageMode.StorageFirst||u===e.StorageMode.StorageAndUpdate){const t=await o.get(b||"");if(void 0!==t&&(E(t),u===e.StorageMode.StorageFirst))return t}if(!navigator.onLine){if(u===e.StorageMode.NetworkFirst){const e=await o.get(b||"");if(void 0!==e)return E(e),e}const t=new Error("System is offline");return T(t),Promise.reject(t)}try{const t=P(i);await(r?.authenticate(this));const d=await Promise.race([fetch(s,{method:a,credentials:c,headers:n,body:t,signal:v.signal}),this.handleTimeout(p)]);if(f?.canceled)return Promise.reject(new Error("The request was canceled."));if(d.status>=200&&d.status<300){const t=await D(d);return E(t),u!==e.StorageMode.NetworkOnly&&await o.set(b||"",t),t}j=new Error(d.statusText),401===d.status&&await(r?.authenticationFailed(this,d))}catch(e){j=e}return S<(w||0)?(++S,await new Promise((e=>setTimeout(e,m))),L(S),O()):(T(j),Promise.reject(j))};return O()}async handleTimeout(e){throw e??=6e4,await new Promise(((t,r)=>{setTimeout((()=>{r(new Error("Request timeout"))}),e)})),new Error("Request timeout")}}var i;e.StorageMode=void 0,(i=e.StorageMode||(e.StorageMode={}))[i.NetworkFirst=0]="NetworkFirst",i[i.StorageFirst=1]="StorageFirst",i[i.NetworkOnly=2]="NetworkOnly",i[i.StorageAndUpdate=3]="StorageAndUpdate",e.Cache=o,e.CancellationToken=class{constructor(){this.canceled=!1}},e.IndexedDbStorageProvider=a,e.Request=s}));
